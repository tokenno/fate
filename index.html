<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blowback</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: linear-gradient(135deg, #0a0a1a, #1a0a1a); color: #f0f0f0; font-family: 'Arial', sans-serif; }
        canvas { position: fixed; top: 0; left: 0; z-index: -1; opacity: 0.6; }
        .glitch { animation: glitch 0.3s linear infinite; }
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }
        .control-panel {
            background: rgba(10, 10, 10, 0.3);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 0, 100, 0.3);
            border-radius: 10px;
            padding: 20px;
            animation: panel-glow 1.5s ease-in-out infinite;
        }
        @keyframes panel-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 100, 0.3); }
            50% { box-shadow: 0 0 20px rgba(100, 0, 255, 0.5); }
        }
        .tooltip { position: relative; }
        .tooltip:hover::after {
            content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #000; color: #f0f0f0; padding: 5px 10px; border-radius: 5px; font-size: 12px; z-index: 10;
        }
        .glitch-button {
            position: relative;
            background: #000;
            border: 2px solid #ff0066;
            border-radius: 5px;
            padding: 8px 16px;
            color: #f0f0f0;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 16px;
            text-transform: uppercase;
            filter: url(#glitch-filter);
            animation: button-flicker 0.3s linear infinite;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .bold-button {
            border: 4px solid #00ffcc;
            font-weight: 900;
        }
        .glitch-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0066;
        }
        .bold-button:hover {
            box-shadow: 0 0 20px #00ffcc;
        }
        .glitch-button:active {
            transform: scale(0.95);
            filter: url(#glitch-filter-intense);
        }
        @keyframes button-flicker {
            0%, 100% { border-color: #ff0066; box-shadow: 0 0 10px #ff0066; }
            50% { border-color: #6600ff; box-shadow: 0 0 15px #6600ff; }
        }
        .bold-button-flicker {
            animation: bold-button-flicker 0.3s linear infinite;
        }
        @keyframes bold-button-flicker {
            0%, 100% { border-color: #00ffcc; box-shadow: 0 0 10px #00ffcc; }
            50% { border-color: #6600ff; box-shadow: 0 0 15px #6600ff; }
        }
        .section-header {
            text-shadow: 0 0 8px #ff0066;
        }
        .help-button {
            position: absolute; top: 705px; right: 370px;
            background: #000; border: 2px solid #ff0066;
            border-radius: 50%; width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; cursor: pointer; transition: transform 0.2s;
        }
        .help-button:hover { transform: scale(1.1); box-shadow: 0 0 15px #ff0066; }
        .help-popup {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(10, 10, 10, 0.9);
            border: 2px solid #ff0066; border-radius: 10px; padding: 20px;
            max-height: 80vh; overflow-y: auto; z-index: 1000;
            color: #f0f0f0; font-size: 14px;
        }
        .help-popup.show { display: block; }
        .close-button {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none; color: #ff0066;
            font-size: 24px; cursor: pointer;
        }
        .logo {
            text-align: center; margin-bottom: 20px; font-size: 18px;
        }
        .logo img {
            max-width: 100px; height: auto;
            filter: drop-shadow(0 0 10px #ff0066) drop-shadow(0 0 15px #6600ff);
            animation: logo-glow 1.5s ease-in-out infinite;
        }
        @keyframes logo-glow {
            0%, 100% { filter: drop-shadow(0 0 10px #ff0066) drop-shadow(0 0 15px #6600ff); }
            50% { filter: drop-shadow(0 0 15px #6600ff) drop-shadow(0 0 20px #ff0066); }
        }
        /* Updated styles for changing green color with animation */
.random-override-label {
    color: #028ec1; /* Base green color */
}
.midi-override-label {
    color: #79a2be; /* Base green color */

}

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">
    <svg style="position: absolute; width: 0; height: 0;">
        <filter id="glitch-filter">
            <feTurbulence type="fractalNoise" baseFrequency="0.1" numOctaves="1" result="noise"/>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
        <filter id="glitch-filter-intense">
            <feTurbulence type="fractalNoise" baseFrequency="0.1" numOctaves="1" result="noise"/>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="12" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
    </svg>
    <canvas id="visuals" class="w-full h-full"></canvas>
    <div class="logo">
        <img src="fate192.png" alt="Fate Logo">
    </div>
   <br> <br> <br> <br>
    <h2 class="glitch-button bold-button bold-button-flicker">Blowback</h2><br>
    <div class="control-panel w-full max-w-4xl">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-start">
            <div class="space-y-4 relative">
                <h2 class="glitch-button bold-button bold-button-flicker">Oscillator</h2>
                <div class="slider-container tooltip" data-tooltip="Base frequency (20-4000 Hz)">
                    <label class="block text-base font-bold">Frequency</label>
                    <input type="range" id="freq" min="20" max="4000" value="440" class="w-full">
                       <label class="random-override-label"><input type="checkbox" id="freqRandom" checked> Frequency Random</label>
                </div>
                <div class="slider-container tooltip" data-tooltip="Modulation depth (0-2000 Hz)">
                    <label class="block text-base font-bold">Mod Depth</label>
                    <input type="range" id="modDepth" min="0" max="2000" step="1" value="500" class="w-full">
                      <label class="random-override-label"><input type="checkbox" id="modDepthRandom" checked> Mod Depth Random</label>
                </div>
                <div class="slider-container tooltip" data-tooltip="Low-pass filter cutoff (60-20000 Hz)">
                    <label class="block text-base font-bold">Filter Cutoff</label>
                    <input type="range" id="filterCutoff" min="60" max="20000" value="1000" class="w-full">
                      <label class="random-override-label"><input type="checkbox" id="filterCutoffRandom" checked> Filter Cutoff Random</label>
                </div>
                <div class="slider-container tooltip" data-tooltip="Randomization interval (20ms-5s)">
                    <label class="block text-base font-bold">Random Interval: <span id="randomIntervalValue">50ms</span></label>
                    <input type="range" id="randomInterval" min="0.02" max="5" step="0.01" value="0.05" class="w-full">
                </div>
            </div>
            <div class="space-y-4">
                <h2 class="glitch-button bold-button bold-button-flicker">LFO</h2>
                <div class="slider-container tooltip" data-tooltip="LFO rate (0-50 Hz)">
                    <label class="block text-base font-bold">LFO Rate</label>
                    <input type="range" id="lfoRate" min="0" max="50" value="5" class="w-full">
                        <label class="random-override-label"><input type="checkbox" id="lfoRateRandom" checked> LFO Rate Random</label>
                </div>
               <div class="slider-container tooltip" data-tooltip="LFO amplitude (0-2)">
        <label class="block text-base font-bold">LFO Amp</label>
        <input type="range" id="lfoAmp" min="0" max="2" step="0.01" value="0.5" class="w-full">
        <label class="random-override-label"><input type="checkbox" id="lfoAmpRandom" checked> LFO Amp Random</label>
    </div>

                <div class="slider-container tooltip" data-tooltip="Sensor sensitivity (0.5x-2x)">
                    <label class="block text-base font-bold">Sensor Sensitivity: <span id="sensorSensitivityValue">1</span>x</label>
                    <input type="range" id="sensorSensitivity" min="0.5" max="2" step="0.1" value="1" class="w-full">
                </div>
                <div class="slider-container tooltip" data-tooltip="Select LFO waveform (0=Sine, 1=Square, 2=Sample & Hold)">
                    <label class="block text-base font-bold">LFO Shape: <span id="lfoShapeValue">Sine</span></label>
                    <input type="range" id="lfoShape" min="0" max="2" step="1" value="0" class="w-full">
                </div>
            </div>
            <div class="space-y-4 relative">
                <h2 class="glitch-button bold-button bold-button-flicker">Effects</h2>
               <div class="slider-container tooltip" data-tooltip="Distortion amount (0-2)">
        <label class="block text-base font-bold">Distortion</label>
        <input type="range" id="distortion" min="0" max="2" step="0.01" value="0.2" class="w-full">
        <label class="random-override-label"><input type="checkbox" id="distortionRandom" checked> Distortion Random</label>
    </div>
                <div class="slider-container tooltip" data-tooltip="Reverb size (0.5-5s)">
        <label class="block text-base font-bold">Reverb Size: <span id="reverbSizeValue">2</span>s</label>
        <input type="range" id="reverbSize" min="0.5" max="5" step="0.1" value="2" class="w-full">
        <label class="random-override-label"><input type="checkbox" id="reverbSizeRandom" checked> Reverb Size Random</label>
    </div>
    <div class="slider-container tooltip" data-tooltip="Reverb feedback (0-0.95)">
        <label class="block text-base font-bold">Reverb Feedback: <span id="reverbFeedbackValue">0.5</span></label>
        <input type="range" id="reverbFeedback" min="0" max="0.95" step="0.01" value="0.5" class="w-full">
        <label class="random-override-label"><input type="checkbox" id="reverbFeedbackRandom" checked> Reverb Feedback Random</label>
    </div>
                <div class="slider-container tooltip" data-tooltip="Freeze trigger threshold (0-20 m/s²)">
                    <label class="block text-base font-bold">Freeze Threshold: <span id="freezeThresholdValue">18</span> m/s²</label>
                    <input type="range" id="freezeThreshold" min="0" max="20" step="0.1" value="18" class="w-full">
                </div>
                <div class="help-button" id="helpButton">?</div>
            </div>
        </div>
        <div class="space-y-4 mt-6">
    <h2 class="glitch-button bold-button bold-button-flicker">Playback Controls</h2>
    <div class="slider-container tooltip" data-tooltip="Set recording duration (1-4 seconds)">
        <label class="block text-base font-bold">Record Duration: <span id="recordDurationValue">1</span>s</label>
        <input type="range" id="recordDuration" min="1" max="4" step="0.1" value="1" class="w-full">
    </div>
    <div class="flex justify-center gap-4">
        <button id="playToggle" class="glitch-button bold-button bold-button-flicker rounded-full w-12 h-12 flex items-center justify-center">▶</button>
        <button id="recordTogglePlayback" class="glitch-button bold-button bold-button-flicker rounded-full w-12 h-12 flex items-center justify-center">●</button>
        <button id="stopToggle" class="glitch-button bold-button bold-button-flicker">■</button>
    </div>
</div>
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <button id="oscToggle" class="glitch-button bold-button bold-button-flicker">Start Osc</button>
            <button id="lfoToggle" class="glitch-button bold-button bold-button-flicker">Start LFO</button>
             <button id="randomizeToggle" class="glitch-button bold-button bold-button-flicker">Randomize Every <span id="randomToggleText">50ms</span></button>
                  <button id="freezeToggle" class="glitch-button bold-button bold-button-flicker">Freeze Effect</button>
                      <button id="reverbToggle" class="glitch-button">Enable Reverb</button>
            <button id="reverbRandomToggle" class="glitch-button">Include Reverb in Random</button>
            <button id="sensorToggle" class="glitch-button">Enable Sensors</button>
              <button id="freezeSensorToggle" class="glitch-button">Enable Freeze Sensor</button>
               <button id="freezeModeToggle" class="glitch-button">Freeze: Shake Mode</button>
            <button id="calibrateToggle" class="glitch-button">Calibrate Sensors</button>
  
            <button id="recordToggle" class="glitch-button bold-button bold-button-flicker">Start Recording</button>
            <button id="midiToggle" class="glitch-button">Disable MIDI</button>
            <div class="mt-4 flex justify-center gap-4">
                <select id="midiOutputSelect" class="glitch-button" style="padding: 8px; width: 200px;">
                    <option value="" disabled selected>Select MIDI Output Port</option>
                </select>
                <select id="midiChannelSelect" class="glitch-button" style="padding: 8px; width: 150px;">
                    <option value="0" disabled selected>Select MIDI Channel</option>
                    <option value="0">Channel 1</option>
                    <option value="1">Channel 2</option>
                    <option value="2">Channel 3</option>
                    <option value="3">Channel 4</option>
                    <option value="4">Channel 5</option>
                    <option value="5">Channel 6</option>
                    <option value="6">Channel 7</option>
                    <option value="7">Channel 8</option>
                    <option value="8">Channel 9</option>
                    <option value="9">Channel 10</option>
                    <option value="10">Channel 11</option>
                    <option value="11">Channel 12</option>
                    <option value="12">Channel 13</option>
                    <option value="13">Channel 14</option>
                    <option value="14">Channel 15</option>
                    <option value="15">Channel 16</option>
                </select>
            </div>
            <div class="mt-4 flex justify-center gap-4">
                <select id="attractorSelect" class="glitch-button" style="padding: 8px; width: 200px;">
                    <option value="lorenz">Lorenz Attractor</option>
                    <option value="rossler">Rössler Attractor</option>
                    <option value="chua">Chua Attractor</option>
                </select>
            </div>
       <div id="modMatrix" class="mt-4 grid grid-cols-2 gap-2">
  
    <label class="midi-override-label"><input type="checkbox" id="freqMidi" checked> Frequency (CC 18)</label>
    <label class="midi-override-label"><input type="checkbox" id="modDepthMidi" checked> Mod Depth (CC 19)</label>
    <label class="midi-override-label"><input type="checkbox" id="filterCutoffMidi" checked> Filter Cutoff (CC 20)</label>
    <label class="midi-override-label"><input type="checkbox" id="lfoRateMidi" checked> LFO Rate (CC 21)</label>
    <label class="midi-override-label"><input type="checkbox" id="lfoAmpMidi" checked> LFO Amp (CC 22)</label>
    <label class="midi-override-label"><input type="checkbox" id="distortionMidi" checked> Distortion (CC 23)</label>
    <label class="midi-override-label"><input type="checkbox" id="reverbFeedbackMidi" checked> Reverb Feedback (CC 24)</label>
    <label class="midi-override-label"><input type="checkbox" id="reverbSizeMidi" checked> Reverb Size (CC 25)</label>
</div>
            <button id="modeToggle" class="glitch-button">Switch to Gradual Mode</button>
        </div>
    </div>
    <div class="mt-4 text-base font-bold" style="text-shadow: 0 0 5px rgba(255, 0, 100, 0.5);">
        MIDI: <span id="midiStatus">Not connected</span> | 
        Sensors: <span id="sensorStatus">Not active (Hold steady and click 'Calibrate Sensors')</span> | 
        Recording: <span id="recordStatus">Not recording</span>
    </div>
    <div id="helpPopup" class="help-popup">
        <button class="close-button" id="closeHelp">×</button>
        <h3 class="text-xl font-bold glitch section-header">Blowback Features & Help</h3>
        <p><strong>ABOUT:</strong></p>
        <ul><li><strong>Blowback</strong> is a synthesizer based on Phase Modulation Synthesis.</li>
            <li><strong>Inspiration</strong> for its development sparkled from a Pure Data patch, then ported and finalized in JavaScript and Web Audio API.</li>
            <li><strong>Blowback</strong> is made to be played live.</li>
            <li><strong>Random Interval:</strong> Set it very low for a non-stop modulation joyride, now starting at 50ms for fast initial randomization.</li></ul>
        <p><strong>Oscillator Controls:</strong></p>
        <ul><li><strong>Frequency:</strong> Adjusts the base pitch (20-4000 Hz).</li>
            <li><strong>Mod Depth:</strong> Sets modulation depth (0-2000 Hz).</li>
            <li><strong>Filter Cutoff:</strong> Controls low-pass filter cutoff (60-20000 Hz).</li>
            <li><strong>Random Interval:</strong> Sets randomization interval (20ms-5s), now initialized at 50ms.</li></ul>
        <p><strong>LFO Controls:</strong></p>
        <ul><li><strong>LFO Rate:</strong> Adjusts LFO rate (0-50 Hz).</li>
            <li><strong>LFO Amp:</strong> Sets LFO amplitude (0-2).</li>
            <li><strong>Sensor Sensitivity:</strong> Scales sensor input (0.5x-2x).</li>
            <li><strong>LFO Shape:</strong> Selects waveform (0=Sine, 1=Square, 2=Sample & Hold, 3=Random).</li></ul>
        <p><strong>Effects Controls:</strong></p>
        <ul><li><strong>Distortion:</strong> Adjusts distortion amount (0-2).</li>
            <li><strong>Reverb Size:</strong> Sets reverb impulse size (0.5-5s).</li>
            <li><strong>Reverb Feedback:</strong> Controls reverb feedback (0-0.95).</li>
            <li><strong>Freeze Threshold:</strong> Sets freeze trigger threshold (0-20 m/s²) for sensor-based freezing.</li></ul>
        <p><strong>Button Controls:</strong></p>
        <ul><li><strong>Start Osc:</strong> Starts/stops the oscillator.</li>
            <li><strong>Start LFO:</strong> Enables/disables the LFO.</li>
            <li><strong>Enable Sensors:</strong> Toggles sensor input (disables random when enabled).</li>
            <li><strong>Calibrate Sensors:</strong> Calibrates sensor baseline.</li>
            <li><strong>Freeze Effect:</strong> Freezes/unfreezes audio buffer, capturing current state including reverb.</li>
            <li><strong>Freeze: Shake Mode/Tilt Mode:</strong> Switches freeze trigger mode between shake and tilt detection.</li>
            <li><strong>Enable Freeze Sensor:</strong> Toggles freeze activation via sensor input.</li>
            <li><strong>Randomize Every Xs:</strong> Starts/stops parameter randomization, now starting at 50ms intervals.</li>
            <li><strong>Switch to Gradual Mode:</strong> Toggles between random and smooth gradual modulation.</li>
            <li><strong>Enable Reverb:</strong> Toggles reverb effect.</li>
            <li><strong>Include Reverb in Random:</strong> Includes/excludes reverb in randomization.</li>
            <li><strong>Start Recording:</strong> Starts/stops audio recording (up to 5 minutes).</li>
            <li><strong>Disable MIDI:</strong> Toggles MIDI output.</li></ul>
        <p><strong>Visuals & Status:</strong></p>
        <ul><li><strong>Dot Visual:</strong> Minimal moving dot with trail.</li>
            <li><strong>MIDI Status:</strong> Displays MIDI connection state.</li>
            <li><strong>Sensors Status:</strong> Shows sensor activity and mode.</li>
            <li><strong>Recording Status:</strong> Indicates recording state and duration.</li></ul>
        <p><strong>MIDI Controllers:</strong></p>
        <ul><li><strong>MIDI Output:</strong> Select the output port.</li>
            <li><strong>MIDI Channel:</strong> Choose the MIDI channel (1-16).</li>
            <li><strong>Modulation Matrix:</strong> Select which parameters send MIDI CC (18-25).</li></ul>
        <p><strong>Notes:</strong> Requires HTTPS for sensors and modern browsers for MIDI/recording. Use MIDI CC 18-25 for parameter control. Freeze feature uses offline rendering to capture audio state, including reverb.</p>
    </div>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    let osc, lfo, modGain, lfoAmpGain, filter, distortion, freezeSource, output, analyser, reverb, reverbGain, dryGain;
    let isOscPlaying = false, isLfoActive = false, isFreezeActive = false, isRandomizing = false, isSensorActive = false, isReverbActive = false, isReverbRandomized = true, isRecording = false, isFreezeShakeMode = true, isFreezeSensorActive = true;
    let freezeBuffer = null, recorder, recordStartTime = 0;
    let calibrationData = { x: 0, y: 0 }, isCalibrating = false, lastFreezeTrigger = 0;
    let midiOutput = null, midiChannel = 0, isMidiActive = true, lastMidiSendTime = 0;
    let isGradualMode = false, attractorState1 = { x: 0.1, y: 0.1, z: 0.1 }, attractorState2 = { x: 1.0, y: 1.0, z: 1.0 }, lastAttractorUpdate = 0;
    let randomizeInterval, transitionProgress = 0, transitionDuration = 0, targetParams = {};
    let isPlayingBack = false, isRecordingPlayback = false, playbackBuffer = [], playbackIndex = 0, playbackStartTime = 0;
   let recordedParams = ['freq', 'modDepth', 'lfoRate', 'lfoAmp', 'filterCutoff', 'distortion', 'reverbFeedback', 'reverbSize'];
    
    // Store manual slider values when checkboxes are deselected
     let manualValues = {
        freq: 440,
        modDepth: 500,
        lfoRate: 5,
        filterCutoff: 1000,
        reverbFeedback: 0.5,
        reverbSize: 2,
        lfoAmp: 0.5,
        distortion: 0.2
    };


function updatePlaybackParams() {
    if (isPlayingBack && playbackBuffer.length > 0) {
        const now = performance.now();
        const elapsed = (now - playbackStartTime) / 1000;
        const duration = parseFloat(document.getElementById('recordDuration').value);
        if (elapsed >= duration) {
            playbackIndex = 0;
            playbackStartTime = now;
        }
        const t = (elapsed % duration) / duration * playbackBuffer.length;
        const i = Math.floor(t);
        const nextI = (i + 1) % playbackBuffer.length;
        const progress = t - i;
        recordedParams.forEach(param => {
            const startValue = playbackBuffer[i][param];
            const endValue = playbackBuffer[nextI][param];
            const interpolatedValue = interpolateValue(startValue, endValue, progress).toFixed(2);
            document.getElementById(param).value = interpolatedValue;
            // Update UI labels
            switch (param) {
                case 'reverbSize':
                    document.getElementById('reverbSizeValue').textContent = interpolatedValue;
                    break;
                case 'reverbFeedback':
                    document.getElementById('reverbFeedbackValue').textContent = interpolatedValue;
                    break;
                case 'randomInterval':
                    document.getElementById('randomIntervalValue').textContent = interpolatedValue < 1 ? (interpolatedValue * 1000).toFixed(0) + 'ms' : interpolatedValue.toFixed(1) + 's';
                    break;
            }
        });
        updateParams();
        requestAnimationFrame(updatePlaybackParams);
    }
}

document.getElementById('recordDuration').addEventListener('input', () => {
    const duration = parseFloat(document.getElementById('recordDuration').value);
    document.getElementById('recordDurationValue').textContent = duration.toFixed(1);
});

document.getElementById('playToggle').addEventListener('click', () => {
    if (!isPlayingBack && !isRecordingPlayback && playbackBuffer.length > 0) {
        console.log('Starting playback with buffer length:', playbackBuffer.length);
        isPlayingBack = true;
        playbackIndex = 0;
        playbackStartTime = performance.now();
        updatePlaybackParams();
    }
});

document.getElementById('recordTogglePlayback').addEventListener('click', () => {
    if (!isRecordingPlayback) {
        console.log('Starting recording playback');
        isRecordingPlayback = true;
        playbackBuffer = [];
        const startTime = performance.now();
        const duration = parseFloat(document.getElementById('recordDuration').value) * 1000;
        const interval = setInterval(() => {
            if (isRecordingPlayback) {
                const elapsed = performance.now() - startTime;
                if (elapsed <= duration) {
                    const snapshot = {};
                    recordedParams.forEach(param => {
                        snapshot[param] = parseFloat(document.getElementById(param).value);
                    });
                    playbackBuffer.push(snapshot);
                    console.log('Recorded snapshot:', snapshot);
                } else {
                    clearInterval(interval);
                    isRecordingPlayback = false;
                    console.log('Recording complete, buffer length:', playbackBuffer.length);
                }
            } else {
                clearInterval(interval);
            }
        }, 50); // Record every 50ms
    }
});

document.getElementById('stopToggle').addEventListener('click', () => {
    isPlayingBack = false;
    isRecordingPlayback = false;
    playbackIndex = 0;
    if (!isRandomizing) {
        recordedParams.forEach(param => {
            document.getElementById(param).value = manualValues[param];
            // Update UI labels
            switch (param) {
                case 'reverbSize':
                    document.getElementById('reverbSizeValue').textContent = manualValues[param];
                    break;
                case 'reverbFeedback':
                    document.getElementById('reverbFeedbackValue').textContent = manualValues[param];
                    break;
                case 'randomInterval':
                    document.getElementById('randomIntervalValue').textContent = manualValues[param] < 1 ? (manualValues[param] * 1000).toFixed(0) + 'ms' : manualValues[param].toFixed(1) + 's';
                    break;
            }
        });
        updateParams();
    }
    console.log('Stopped playback/recording');
});

    function initAudio() {
        osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(440, ctx.currentTime);
        lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.setValueAtTime(5, ctx.currentTime);
        modGain = ctx.createGain(); modGain.gain.setValueAtTime(500, ctx.currentTime);
        lfoAmpGain = ctx.createGain(); lfoAmpGain.gain.setValueAtTime(0.5, ctx.currentTime);
        filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(1000, ctx.currentTime);
        distortion = ctx.createWaveShaper(); distortion.curve = makeDistortionCurve(0.2);
        analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
        reverb = ctx.createConvolver(); reverb.buffer = generateReverbImpulse(2);
        reverbGain = ctx.createGain(); reverbGain.gain.setValueAtTime(0.5, ctx.currentTime);
        dryGain = ctx.createGain(); dryGain.gain.setValueAtTime(0.5, ctx.currentTime);
        output = ctx.createGain(); output.gain.setValueAtTime(0.95, ctx.currentTime);
        lfo.connect(modGain); modGain.connect(osc.frequency); lfo.connect(lfoAmpGain); lfoAmpGain.connect(output.gain);
        osc.connect(distortion); distortion.connect(filter); filter.connect(analyser); analyser.connect(dryGain);
        analyser.connect(reverb); reverb.connect(reverbGain); dryGain.connect(output); reverbGain.connect(output);
        output.connect(ctx.destination);
        const stream = ctx.createMediaStreamDestination(); output.connect(stream);
        recorder = new MediaRecorder(stream.stream, { mimeType: 'audio/webm' });
        const chunks = []; recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => { const blob = new Blob(chunks, { type: 'audio/wav' }); const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `butPlug_AutoX_recording_${new Date().toISOString().replace(/[:.]/g, '-')}.wav`;
            a.click(); URL.revokeObjectURL(url); chunks.length = 0; };
    }

    function generateReverbImpulse(size) {
        const sampleRate = ctx.sampleRate; const length = sampleRate * size;
        const impulse = ctx.createBuffer(2, length, sampleRate);
        const left = impulse.getChannelData(0); const right = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) { const decay = Math.exp(-i / (sampleRate * size) * 8);
            left[i] = (Math.random() * 2 - 1) * decay; right[i] = (Math.random() * 2 - 1) * decay; }
        return impulse;
    }

    function makeDistortionCurve(amount) {
        const samples = 44100; const curve = new Float32Array(samples);
        for (let i = 0; i < samples; i++) { const x = (i * 2) / samples - 1; curve[i] = Math.tanh(x * (1 + amount * 10)); }
        return curve;
    }

    async function toggleFreeze() {
        isFreezeActive = !isFreezeActive;
        if (isFreezeActive) {
            try {
                const offlineCtx = new OfflineAudioContext(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                const oscCopy = offlineCtx.createOscillator(); oscCopy.type = osc.type;
                oscCopy.frequency.setValueAtTime(osc.frequency.value, 0);
                const lfoCopy = offlineCtx.createOscillator(); lfoCopy.type = lfo.type;
                lfoCopy.frequency.setValueAtTime(lfo.frequency.value, 0);
                const modGainCopy = offlineCtx.createGain(); modGainCopy.gain.setValueAtTime(modGain.gain.value, 0);
                const lfoAmpGainCopy = offlineCtx.createGain(); lfoAmpGainCopy.gain.setValueAtTime(lfoAmpGain.gain.value, 0);
                const filterCopy = offlineCtx.createBiquadFilter(); filterCopy.type = filter.type;
                filterCopy.frequency.setValueAtTime(filter.frequency.value, 0);
                const distortionCopy = offlineCtx.createWaveShaper(); distortionCopy.curve = distortion.curve;
                const reverbCopy = offlineCtx.createConvolver(); reverbCopy.buffer = reverb.buffer;
                const reverbGainCopy = offlineCtx.createGain(); reverbGainCopy.gain.setValueAtTime(reverbGain.gain.value, 0);
                const dryGainCopy = offlineCtx.createGain(); dryGainCopy.gain.setValueAtTime(dryGain.gain.value, 0);
                const outputCopy = offlineCtx.createGain(); outputCopy.gain.setValueAtTime(output.gain.value, 0);

                lfoCopy.connect(modGainCopy); modGainCopy.connect(oscCopy.frequency);
                lfoCopy.connect(lfoAmpGainCopy); lfoAmpGainCopy.connect(outputCopy.gain);
                oscCopy.connect(distortionCopy); distortionCopy.connect(filterCopy);
                filterCopy.connect(dryGainCopy); filterCopy.connect(reverbCopy);
                reverbCopy.connect(reverbGainCopy); dryGainCopy.connect(outputCopy);
                reverbGainCopy.connect(outputCopy);
                outputCopy.connect(offlineCtx.destination);

                oscCopy.start(0); lfoCopy.start(0);
                const renderedBuffer = await offlineCtx.startRendering();
                freezeBuffer = ctx.createBuffer(1, renderedBuffer.length, ctx.sampleRate);
                freezeBuffer.copyToChannel(renderedBuffer.getChannelData(0), 0);

                freezeSource = ctx.createBufferSource();
                freezeSource.buffer = freezeBuffer;
                freezeSource.loop = true;
                freezeSource.connect(output);
                freezeSource.start(0);

                osc.disconnect();
                lfo.disconnect();
            } catch (e) {
                console.error('Freeze capture failed:', e);
            }
        } else {
            if (freezeSource) {
                freezeSource.stop();
                freezeSource.disconnect();
                freezeSource = null;
                freezeBuffer = null;
            }
            osc.connect(distortion);
            lfo.connect(modGain);
            lfo.connect(lfoAmpGain);
        }
        document.getElementById('freezeToggle').textContent = isFreezeActive ? 'Unfreeze' : 'Freeze Effect';
    }

    function toggleReverb() { 
        isReverbActive = !isReverbActive;
        reverbGain.gain.setValueAtTime(isReverbActive ? document.getElementById('reverbFeedback').value : 0, ctx.currentTime);
        dryGain.gain.setValueAtTime(isReverbActive ? (1 - document.getElementById('reverbFeedback').value) : 1, ctx.currentTime);
        document.getElementById('reverbToggle').textContent = isReverbActive ? 'Disable Reverb' : 'Enable Reverb'; 
    }

    function toggleReverbRandom() { 
        isReverbRandomized = !isReverbRandomized;
        document.getElementById('reverbRandomToggle').textContent = isReverbRandomized ? 'Exclude Reverb from Random' : 'Include Reverb in Random'; 
    }

    function toggleFreezeMode() { 
        isFreezeShakeMode = !isFreezeShakeMode;
        document.getElementById('freezeModeToggle').textContent = isFreezeShakeMode ? 'Freeze: Tilt Mode' : 'Freeze: Shake Mode';
        document.getElementById('sensorStatus').textContent = isSensorActive ? `Active (Calibrated, ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})` : `Supported (Hold steady and click 'Calibrate Sensors', ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})`; 
    }

    function toggleFreezeSensor() { 
        isFreezeSensorActive = !isFreezeSensorActive;
        document.getElementById('freezeSensorToggle').textContent = isFreezeSensorActive ? 'Disable Freeze Sensor' : 'Enable Freeze Sensor';
        document.getElementById('sensorStatus').textContent = isSensorActive ? `Active (Calibrated, ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})` : `Supported (Hold steady and click 'Calibrate Sensors', ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})`; 
    }

    function toggleRecording() { 
        if (!isRecording) { 
            if (!isOscPlaying) { alert('Start the oscillator first to record audio.'); return; }
            recorder.start(); isRecording = true; recordStartTime = performance.now(); document.getElementById('recordToggle').textContent = 'Stop Recording';
            document.getElementById('recordStatus').textContent = 'Recording... 0s'; const updateTime = setInterval(() => {
                if (!isRecording) { clearInterval(updateTime); return; } const elapsed = (performance.now() - recordStartTime) / 1000;
                document.getElementById('recordStatus').textContent = `Recording... ${elapsed.toFixed(1)}s`; if (elapsed >= 300) toggleRecording(); }, 100);
        } else { 
            recorder.stop(); isRecording = false; document.getElementById('recordToggle').textContent = 'Start Recording';
            document.getElementById('recordStatus').textContent = 'Not recording'; 
        } 
    }

    const attractors = {
        lorenz: { sigma: 10, rho: 28, beta: 8/3 },
        rossler: { a: 0.2, b: 0.2, c: 5.7 },
        chua: { a: 15.6, b: 28, m0: -1.143, m1: -0.714 }
    };

    function updateAttractor(attractorType) {
        const dt = 0.01; const params = attractors[attractorType];
        let { x: x1, y: y1, z: z1 } = attractorState1;
        if (attractorType === 'lorenz') {
            attractorState1.x = x1 + dt * params.sigma * (y1 - x1);
            attractorState1.y = y1 + dt * (x1 * (params.rho - z1) - y1);
            attractorState1.z = z1 + dt * (x1 * y1 - params.beta * z1);
        } else if (attractorType === 'rossler') {
            attractorState1.x = x1 + dt * (-y1 - z1);
            attractorState1.y = y1 + dt * (x1 + params.a * y1);
            attractorState1.z = z1 + dt * (params.b + z1 * (x1 - params.c));
        } else if (attractorType === 'chua') {
            const h = params.m1 * x1 + 0.5 * (params.m0 - params.m1) * (Math.abs(x1 + 1) - Math.abs(x1 - 1));
            attractorState1.x = x1 + dt * params.a * (y1 - x1 - h);
            attractorState1.y = y1 + dt * (x1 - y1 + z1);
            attractorState1.z = z1 + dt * (-params.b * y1);
        }
        let { x: x2, y: y2, z: z2 } = attractorState2;
        if (attractorType === 'lorenz') {
            attractorState2.x = x2 + dt * params.sigma * (y2 - x2);
            attractorState2.y = y2 + dt * (x2 * (params.rho - z2) - y2);
            attractorState2.z = z2 + dt * (x2 * y2 - params.beta * z2);
        } else if (attractorType === 'rossler') {
            attractorState2.x = x2 + dt * (-y2 - z2);
            attractorState2.y = y2 + dt * (x2 + params.a * y2);
            attractorState2.z = z2 + dt * (params.b + z2 * (x2 - params.c));
        } else if (attractorType === 'chua') {
            const h = params.m1 * x2 + 0.5 * (params.m0 - params.m1) * (Math.abs(x2 + 1) - Math.abs(x2 - 1));
            attractorState2.x = x2 + dt * params.a * (y2 - x2 - h);
            attractorState2.y = y2 + dt * (x2 - y2 + z2);
            attractorState2.z = z2 + dt * (-params.b * y2);
        }
    }

    function interpolateValue(start, end, t) {
        const mu = (1 - Math.cos(t * Math.PI)) / 2;
        return start + (end - start) * mu;
    }

  function setTargetParams() {
        const attractorType = document.getElementById('attractorSelect').value;
        updateAttractor(attractorType);
        if (isGradualMode) {
            targetParams.freq = document.getElementById('freqRandom').checked ? Math.max(20, Math.min(4000, manualValues.freq + ((attractorState1.x + 15) / 30 * 3980 - 2000) * 0.5)) : manualValues.freq;
            targetParams.modDepth = document.getElementById('modDepthRandom').checked ? Math.max(0, Math.min(2000, manualValues.modDepth + ((attractorState1.y + 15) / 30 * 2000 * 0.7 - 700) * 0.5)) : manualValues.modDepth;
            targetParams.lfoRate = document.getElementById('lfoRateRandom').checked ? Math.max(0, Math.min(50, manualValues.lfoRate + ((attractorState1.z + 15) / 30 * 50 * 0.4 - 10) * 0.5)) : manualValues.lfoRate;
            targetParams.lfoAmp = document.getElementById('lfoAmpRandom').checked ? Math.max(0, Math.min(2, manualValues.lfoAmp + ((Math.sin(attractorState1.x) + 1) / 2 * 2))) : manualValues.lfoAmp;
            targetParams.filterCutoff = document.getElementById('filterCutoffRandom').checked ? Math.max(60, Math.min(20000, manualValues.filterCutoff + ((attractorState2.y + 15) / 30 * 19980 - 10000) * 0.5)) : manualValues.filterCutoff;
            targetParams.distortion = document.getElementById('distortionRandom').checked ? Math.max(0, Math.min(2, manualValues.distortion + ((Math.abs(attractorState1.z) + 15) / 30 * 2 * 0.5))) : manualValues.distortion;
            if (isReverbRandomized) {
                targetParams.reverbFeedback = document.getElementById('reverbFeedbackRandom').checked ? Math.max(0, Math.min(0.95, manualValues.reverbFeedback + (((Math.cos(attractorState1.x) + 1) / 2 * 0.95) - 0.475) * 0.5)) : manualValues.reverbFeedback;
                targetParams.reverbSize = document.getElementById('reverbSizeRandom').checked ? Math.max(0.5, Math.min(5, manualValues.reverbSize + (((Math.sin(attractorState1.y) + 1) / 2 * 4.5 + 0.5) - 2.75) * 0.5)) : manualValues.reverbSize;
            } else {
                targetParams.reverbFeedback = manualValues.reverbFeedback;
                targetParams.reverbSize = manualValues.reverbSize;
            }
        } else {
            targetParams.freq = document.getElementById('freqRandom').checked && Math.random() > 0.5 ? Math.max(20, Math.min(4000, manualValues.freq + (Math.random() * 200 - 100))) : manualValues.freq;
            targetParams.modDepth = document.getElementById('modDepthRandom').checked && Math.random() > 0.5 ? Math.max(0, Math.min(2000, manualValues.modDepth + (Math.random() * 200 - 100) * 0.7)) : manualValues.modDepth;
            targetParams.lfoRate = document.getElementById('lfoRateRandom').checked && Math.random() > 0.5 ? Math.max(0, Math.min(50, manualValues.lfoRate + (Math.random() * 5 - 2.5) * 0.4)) : manualValues.lfoRate;
            targetParams.lfoAmp = document.getElementById('lfoAmpRandom').checked && Math.random() > 0.5 ? Math.max(0, Math.min(2, manualValues.lfoAmp + (Math.random() * 0.2 - 0.1))) : manualValues.lfoAmp;
            targetParams.filterCutoff = document.getElementById('filterCutoffRandom').checked && Math.random() > 0.5 ? Math.max(60, Math.min(20000, manualValues.filterCutoff + (Math.random() * 1000 - 500) * 1.2)) : manualValues.filterCutoff;
            targetParams.distortion = document.getElementById('distortionRandom').checked && Math.random() > 0.5 ? Math.max(0, Math.min(2, manualValues.distortion + (Math.random() * 0.2 - 0.1) * 0.5)) : manualValues.distortion;
            if (isReverbRandomized) {
                targetParams.reverbFeedback = document.getElementById('reverbFeedbackRandom').checked && Math.random() > 0.5 ? Math.max(0, Math.min(0.95, manualValues.reverbFeedback + (Math.random() * 0.1 - 0.05))) : manualValues.reverbFeedback;
                targetParams.reverbSize = document.getElementById('reverbSizeRandom').checked && Math.random() > 0.5 ? Math.max(0.5, Math.min(5, manualValues.reverbSize + (Math.random() * 0.5 - 0.25))) : manualValues.reverbSize;
            } else {
                targetParams.reverbFeedback = manualValues.reverbFeedback;
                targetParams.reverbSize = manualValues.reverbSize;
            }
        }
        transitionProgress = 0;
        transitionDuration = parseFloat(document.getElementById('randomInterval').value) * 1000;
    }

   function updateParams() {
        osc.frequency.setValueAtTime(document.getElementById('freq').value, ctx.currentTime);
        modGain.gain.setValueAtTime(document.getElementById('modDepth').value, ctx.currentTime);
        lfo.frequency.setValueAtTime(document.getElementById('lfoRate').value, ctx.currentTime);
        lfoAmpGain.gain.setValueAtTime(document.getElementById('lfoAmp').value, ctx.currentTime);
        filter.frequency.setValueAtTime(document.getElementById('filterCutoff').value, ctx.currentTime);
        distortion.curve = makeDistortionCurve(parseFloat(document.getElementById('distortion').value));
        reverbGain.gain.setValueAtTime(isReverbActive ? document.getElementById('reverbFeedback').value : 0, ctx.currentTime);
        dryGain.gain.setValueAtTime(isReverbActive ? (1 - document.getElementById('reverbFeedback').value) : 1, ctx.currentTime);
        const size = parseFloat(document.getElementById('reverbSize').value); reverb.buffer = generateReverbImpulse(size);

        // Update LFO shape
        const lfoShape = parseInt(document.getElementById('lfoShape').value);
        switch (lfoShape) {
            case 0: lfo.type = 'sine'; break; // Sine
            case 1: lfo.type = 'square'; break; // Square
            case 2: lfo.type = 'square'; lfo.frequency.setValueAtTime(0, ctx.currentTime); // Sample & Hold (simulated with square and step)
                    setTimeout(() => lfo.frequency.setValueAtTime(document.getElementById('lfoRate').value, ctx.currentTime + 0.01), 0);
                    break;
            case 3: lfo.type = 'square'; lfo.frequency.setValueAtTime(0, ctx.currentTime); // Random (simulated with noise-like steps)
                    setTimeout(() => {
                        lfo.frequency.setValueAtTime(document.getElementById('lfoRate').value, ctx.currentTime + 0.01);
                        lfoAmpGain.gain.setValueAtTime(Math.random() * 2, ctx.currentTime + 0.01);
                    }, 0);
                    break;
        }
        document.getElementById('lfoShapeValue').textContent = ['Sine', 'Square', 'Sample & Hold'][lfoShape];

        if (isMidiActive) sendMidiMessage();
        // Update manual values when sliders change
        manualValues.freq = parseFloat(document.getElementById('freq').value);
        manualValues.modDepth = parseFloat(document.getElementById('modDepth').value);
        manualValues.lfoRate = parseFloat(document.getElementById('lfoRate').value);
        manualValues.lfoAmp = parseFloat(document.getElementById('lfoAmp').value);
        manualValues.filterCutoff = parseFloat(document.getElementById('filterCutoff').value);
        manualValues.distortion = parseFloat(document.getElementById('distortion').value);
        manualValues.reverbFeedback = parseFloat(document.getElementById('reverbFeedback').value);
        manualValues.reverbSize = parseFloat(document.getElementById('reverbSize').value);
    }
    function smoothTransition() {
        if (!isRandomizing) {
            transitionProgress = 0;
            return;
        }
        const now = performance.now();
        const step = now - lastAttractorUpdate;
        transitionProgress += step / transitionDuration;
        if (transitionProgress >= 1) {
            transitionProgress = 0;
            setTargetParams();
        }

        if (document.getElementById('freqRandom').checked) {
            document.getElementById('freq').value = interpolateValue(parseFloat(document.getElementById('freq').value), targetParams.freq, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (document.getElementById('modDepthRandom').checked) {
            document.getElementById('modDepth').value = interpolateValue(parseFloat(document.getElementById('modDepth').value), targetParams.modDepth, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (document.getElementById('lfoRateRandom').checked) {
            document.getElementById('lfoRate').value = interpolateValue(parseFloat(document.getElementById('lfoRate').value), targetParams.lfoRate, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (document.getElementById('lfoAmpRandom').checked) {
            document.getElementById('lfoAmp').value = interpolateValue(parseFloat(document.getElementById('lfoAmp').value), targetParams.lfoAmp, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (document.getElementById('filterCutoffRandom').checked) {
            document.getElementById('filterCutoff').value = interpolateValue(parseFloat(document.getElementById('filterCutoff').value), targetParams.filterCutoff, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (document.getElementById('distortionRandom').checked) {
            document.getElementById('distortion').value = interpolateValue(parseFloat(document.getElementById('distortion').value), targetParams.distortion, Math.min(transitionProgress, 1)).toFixed(2);
        }
        if (isReverbRandomized) {
            if (document.getElementById('reverbFeedbackRandom').checked) {
                document.getElementById('reverbFeedback').value = interpolateValue(parseFloat(document.getElementById('reverbFeedback').value), targetParams.reverbFeedback, Math.min(transitionProgress, 1)).toFixed(2);
            }
            if (document.getElementById('reverbSizeRandom').checked) {
                document.getElementById('reverbSize').value = interpolateValue(parseFloat(document.getElementById('reverbSize').value), targetParams.reverbSize, Math.min(transitionProgress, 1)).toFixed(2);
            }
        }

        updateParams();
        lastAttractorUpdate = now;
        requestAnimationFrame(smoothTransition);
    }

    function toggleRandomize() { 
        isRandomizing = !isRandomizing;
        const interval = parseFloat(document.getElementById('randomInterval').value);
        document.getElementById('randomizeToggle').textContent = isRandomizing ? `Stop ${isGradualMode ? 'Gradual' : 'Random'} Every ${interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's'}` : `${isGradualMode ? 'Gradual' : 'Random'} Every ${interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's'}`;
        if (isRandomizing) {
            setTargetParams();
            smoothTransition();
        } else {
            transitionProgress = 0;
            logo.style.transform = 'rotate(0deg)';
        }
    }

    function toggleMode() { 
        isGradualMode = !isGradualMode; 
        attractorState1 = { x: 0.1, y: 0.1, z: 0.1 }; 
        attractorState2 = { x: 1.0, y: 1.0, z: 1.0 };
        const interval = parseFloat(document.getElementById('randomInterval').value);
        document.getElementById('modeToggle').textContent = `Switch to ${isGradualMode ? 'Random' : 'Gradual'} Mode`;
        document.getElementById('randomizeToggle').textContent = isRandomizing ? `Stop ${isGradualMode ? 'Gradual' : 'Random'} Every ${interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's'}` : `${isGradualMode ? 'Gradual' : 'Random'} Every ${interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's'}`;
        if (isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    }

    function initMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(midi => {
                document.getElementById('midiStatus').textContent = 'Connected';
                const outputSelect = document.getElementById('midiOutputSelect');
                midi.outputs.forEach(output => { const option = document.createElement('option');
                    option.value = output.id; option.textContent = output.name; outputSelect.appendChild(option); });
                outputSelect.addEventListener('change', () => { midiOutput = midi.outputs.get(outputSelect.value) || null;
                    document.getElementById('midiStatus').textContent = midiOutput ? 'Connected (Output selected)' : 'Connected (No output)'; });
                document.getElementById('midiChannelSelect').addEventListener('change', e => {
                    midiChannel = parseInt(e.target.value); document.getElementById('midiStatus').textContent = `Connected (Channel ${midiChannel + 1}, Output ${midiOutput ? 'selected' : 'none'})`; });
                midi.inputs.forEach(input => input.onmidimessage = msg => { if (msg.data[0] === 176) {
                    const cc = msg.data[1]; const value = msg.data[2]; const params = [
                        { id: 'freq', cc: 18, min: 20, max: 4000 }, { id: 'modDepth', cc: 19, min: 0, max: 2000 },
                        { id: 'filterCutoff', cc: 20, min: 60, max: 20000 }, { id: 'lfoRate', cc: 21, min: 0, max: 50 },
                        { id: 'lfoAmp', cc: 22, min: 0, max: 2 }, { id: 'distortion', cc: 23, min: 0, max: 2 },
                        { id: 'reverbFeedback', cc: 24, min: 0, max: 0.95 }, { id: 'reverbSize', cc: 25, min: 0.5, max: 5 }];
                    params.forEach(p => { if (cc === p.cc) document.getElementById(p.id).value = p.min + (value / 127) * (p.max - p.min); });
                    updateParams(); } }); }, () => document.getElementById('midiStatus').textContent = 'Failed to connect');
        } else document.getElementById('midiStatus').textContent = 'Web MIDI not supported';
    }

    function sendMidiMessage() {
        const now = performance.now(); if (!isMidiActive || !midiOutput || now - lastMidiSendTime < 50) return;
        const status = 0xB0 + midiChannel; const params = [
            { id: 'freq', cc: 18, min: 20, max: 4000, checkbox: 'freqMidi' },
            { id: 'modDepth', cc: 19, min: 0, max: 2000, checkbox: 'modDepthMidi' },
            { id: 'filterCutoff', cc: 20, min: 60, max: 20000, checkbox: 'filterCutoffMidi' },
            { id: 'lfoRate', cc: 21, min: 0, max: 50, checkbox: 'lfoRateMidi' },
            { id: 'lfoAmp', cc: 22, min: 0, max: 2, checkbox: 'lfoAmpMidi' },
            { id: 'distortion', cc: 23, min: 0, max: 2, checkbox: 'distortionMidi' },
            { id: 'reverbFeedback', cc: 24, min: 0, max: 0.95, checkbox: 'reverbFeedbackMidi' },
            { id: 'reverbSize', cc: 25, min: 0.5, max: 5, checkbox: 'reverbSizeMidi' }];
        params.forEach(param => { if (document.getElementById(param.checkbox).checked) {
            const value = parseFloat(document.getElementById(param.id).value);
            const midiValue = Math.round((value - param.min) / (param.max - param.min) * 127);
            midiOutput.send([status, param.cc, midiValue]); } });
        lastMidiSendTime = now;
    }

    function initSensors() {
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', event => {
                if (isSensorActive) { const accel = event.accelerationIncludingGravity;
                    if (accel.x !== null && accel.y !== null && accel.z !== null) { const sensitivity = parseFloat(document.getElementById('sensorSensitivity').value);
                        const lfoRate = Math.max(0, Math.min(50, ((accel.x - calibrationData.x) / 10) * 50 * sensitivity));
                        const lfoAmp = Math.max(0, Math.min(2, ((accel.y - calibrationData.y) / 10) * 2 * sensitivity));
                        document.getElementById('lfoRate').value = lfoRate; document.getElementById('lfoAmp').value = lfoAmp;
                        updateParams(); if (isFreezeSensorActive) { const threshold = parseFloat(document.getElementById('freezeThreshold').value);
                            const now = performance.now(); if (isFreezeShakeMode) { if (Math.abs(accel.z) > threshold && now - lastFreezeTrigger > 1000) {
                                toggleFreeze(); lastFreezeTrigger = now; } } else { if (accel.z < -8 && now - lastFreezeTrigger > 1000) {
                                toggleFreeze(); lastFreezeTrigger = now; } } } } }
                if (isCalibrating) { calibrationData.x = event.accelerationIncludingGravity.x || 0; calibrationData.y = event.accelerationIncludingGravity.y || 0;
                    isCalibrating = false; document.getElementById('calibrateToggle').textContent = 'Calibrate Sensors';
                    document.getElementById('sensorStatus').textContent = isSensorActive ? `Active (Calibrated, ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})` : `Supported (Hold steady and click 'Calibrate Sensors', ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})`; } });
            document.getElementById('sensorStatus').textContent = `Supported (Hold steady and click 'Calibrate Sensors', ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})`;
        } else { document.getElementById('sensorStatus').textContent = 'Not supported';
            document.getElementById('sensorToggle').disabled = true; document.getElementById('calibrateToggle').disabled = true;
            document.getElementById('freezeModeToggle').disabled = true; document.getElementById('freezeSensorToggle').disabled = true; }
    }

    const canvas = document.getElementById('visuals'); const c = canvas.getContext('2d');
    let dot = { x: canvas.width / 2, y: canvas.height / 2, vx: 1, vy: 1, trail: [] };
    const logo = document.querySelector('.logo img');
    let logoAngle = 0;

    function initCanvas() { 
        canvas.width = window.innerWidth; 
        canvas.height = window.innerHeight; 
        logo.style.position = 'absolute'; 
        logo.style.left = `${(window.innerWidth - logo.width) / 2}px`; // Center horizontally at top
        logo.style.top = '20px'; // 20px from top of page
        logo.style.transformOrigin = 'center center'; // Rotate around center of logo
        animateCanvas(); 
    }

    function animateCanvas() {
        c.fillStyle = 'rgba(0, 0, 0, 0.02)'; c.fillRect(0, 0, canvas.width, canvas.height);
        dot.x += dot.vx; dot.y += dot.vy; if (dot.x < 0 || dot.x > canvas.width) dot.vx *= -1;
        if (dot.y < 0 || dot.y > canvas.height) dot.vy *= -1; dot.trail.push({ x: dot.x, y: dot.y });
        if (dot.trail.length > 5) dot.trail.shift(); c.beginPath(); c.arc(dot.x, dot.y, 2, 0, Math.PI * 2);
        c.fillStyle = 'hsl(300, 70%, 50%)'; c.fill(); dot.trail.forEach((t, i) => {
            c.beginPath(); c.arc(t.x, t.y, 1, 0, Math.PI * 2); c.fillStyle = `rgba(255, 100, 100, ${1 - i / 5})`; c.fill(); });

        // Spin logo based on lfoRate when random mode is on
        if (isRandomizing) {
            const lfoRate = parseFloat(document.getElementById('lfoRate').value) || 0; // Get current LFO rate (0-50)
            logoAngle += lfoRate * 0.001; // Adjust spin speed based on lfoRate (scaled for smooth rotation)
            logo.style.transform = `rotate(${logoAngle}deg)`;
        } else {
            logo.style.transform = 'rotate(0deg)';
        }

        requestAnimationFrame(animateCanvas);
    }

    document.getElementById('oscToggle').addEventListener('click', () => {
        if (!isOscPlaying) { 
            ctx.resume().then(() => { 
                osc.start(); lfo.start(); isOscPlaying = true;
                document.getElementById('oscToggle').textContent = 'Stop Osc'; updateParams(); 
            }).catch(err => console.error('Audio context resume failed:', err)); 
        } else { 
            osc.stop(); lfo.stop(); if (freezeSource) { freezeSource.stop(); freezeSource.disconnect(); freezeSource = null; freezeBuffer = null; }
            isOscPlaying = false; document.getElementById('oscToggle').textContent = 'Start Osc'; initAudio(); updateParams(); 
        } 
    });

    document.getElementById('lfoToggle').addEventListener('click', () => { 
        isLfoActive = !isLfoActive;
        lfo.frequency.setValueAtTime(isLfoActive ? document.getElementById('lfoRate').value : 0, ctx.currentTime);
        document.getElementById('lfoToggle').textContent = isLfoActive ? 'Stop LFO' : 'Start LFO'; 
    });

    document.getElementById('freezeToggle').addEventListener('click', toggleFreeze);
    document.getElementById('freezeModeToggle').addEventListener('click', toggleFreezeMode);
    document.getElementById('freezeSensorToggle').addEventListener('click', toggleFreezeSensor);
    document.getElementById('reverbToggle').addEventListener('click', toggleReverb);
    document.getElementById('reverbRandomToggle').addEventListener('click', toggleReverbRandom);
    document.getElementById('recordToggle').addEventListener('click', toggleRecording);

    document.getElementById('sensorToggle').addEventListener('click', () => { 
        isSensorActive = !isSensorActive;
        document.getElementById('sensorToggle').textContent = isSensorActive ? 'Disable Sensors' : 'Enable Sensors';
        if (isSensorActive && isRandomizing) { isRandomizing = false; transitionProgress = 0;
            document.getElementById('randomizeToggle').textContent = `${isGradualMode ? 'Gradual' : 'Random'} Every ${document.getElementById('randomInterval').value < 1 ? (document.getElementById('randomInterval').value * 1000).toFixed(0) + 'ms' : document.getElementById('randomInterval').value.toFixed(1) + 's'}`; }
        document.getElementById('sensorStatus').textContent = isSensorActive ? `Active (Calibrated, ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})` : `Supported (Hold steady and click 'Calibrate Sensors', ${isFreezeShakeMode ? 'Shake' : 'Tilt'} Mode, Freeze Sensor ${isFreezeSensorActive ? 'On' : 'Off'})`;
        if (!isSensorActive) calibrationData = { x: 0, y: 0 }; 
    });

    document.getElementById('calibrateToggle').addEventListener('click', () => { 
        if (isSensorActive) {
            isCalibrating = true; document.getElementById('calibrateToggle').textContent = 'Calibrating...'; 
        } 
    });

    document.getElementById('randomizeToggle').addEventListener('click', toggleRandomize);
    document.getElementById('modeToggle').addEventListener('click', toggleMode);
    document.getElementById('attractorSelect').addEventListener('change', () => {
        attractorState1 = { x: 0.1, y: 0.1, z: 0.1 }; attractorState2 = { x: 1.0, y: 1.0, z: 1.0 };
        if (isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });
    document.getElementById('randomInterval').addEventListener('input', () => {
        const interval = parseFloat(document.getElementById('randomInterval').value);
        document.getElementById('randomIntervalValue').textContent = interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's';
        document.getElementById('randomToggleText').textContent = interval < 1 ? (interval * 1000).toFixed(0) + 'ms' : interval.toFixed(1) + 's';
        if (isRandomizing) {
            transitionDuration = interval * 1000;
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('sensorSensitivity').addEventListener('input', () => {
        const sensitivity = parseFloat(document.getElementById('sensorSensitivity').value);
        document.getElementById('sensorSensitivityValue').textContent = sensitivity.toFixed(1); 
    });
    document.getElementById('freezeThreshold').addEventListener('input', () => {
        const threshold = parseFloat(document.getElementById('freezeThreshold').value);
        document.getElementById('freezeThresholdValue').textContent = threshold.toFixed(1); 
    });
    document.getElementById('reverbFeedback').addEventListener('input', () => {
        const feedback = parseFloat(document.getElementById('reverbFeedback').value);
        document.getElementById('reverbFeedbackValue').textContent = feedback.toFixed(2); updateParams(); 
    });
    document.getElementById('reverbSize').addEventListener('input', () => {
        const size = parseFloat(document.getElementById('reverbSize').value);
        document.getElementById('reverbSizeValue').textContent = size.toFixed(1); updateParams(); 
    });
    document.getElementById('freq').addEventListener('input', updateParams);
    document.getElementById('modDepth').addEventListener('input', updateParams);
    document.getElementById('lfoRate').addEventListener('input', updateParams);
    document.getElementById('lfoAmp').addEventListener('input', updateParams);
    document.getElementById('filterCutoff').addEventListener('input', updateParams);
    document.getElementById('distortion').addEventListener('input', updateParams);
    document.getElementById('lfoShape').addEventListener('input', updateParams);

    document.getElementById('freqRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.freq = parseFloat(document.getElementById('freq').value);
            document.getElementById('freq').value = manualValues.freq;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('modDepthRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.modDepth = parseFloat(document.getElementById('modDepth').value);
            document.getElementById('modDepth').value = manualValues.modDepth;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('lfoRateRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.lfoRate = parseFloat(document.getElementById('lfoRate').value);
            document.getElementById('lfoRate').value = manualValues.lfoRate;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

       document.getElementById('lfoAmpRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.lfoAmp = parseFloat(document.getElementById('lfoAmp').value);
            document.getElementById('lfoAmp').value = manualValues.lfoAmp;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('distortionRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.distortion = parseFloat(document.getElementById('distortion').value);
            document.getElementById('distortion').value = manualValues.distortion;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('reverbSizeRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.reverbSize = parseFloat(document.getElementById('reverbSize').value);
            document.getElementById('reverbSize').value = manualValues.reverbSize;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('reverbFeedbackRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.reverbFeedback = parseFloat(document.getElementById('reverbFeedback').value);
            document.getElementById('reverbFeedback').value = manualValues.reverbFeedback;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('filterCutoffRandom').addEventListener('change', (e) => {
        if (!e.target.checked && isRandomizing) {
            manualValues.filterCutoff = parseFloat(document.getElementById('filterCutoff').value);
            document.getElementById('filterCutoff').value = manualValues.filterCutoff;
            updateParams();
        } else if (e.target.checked && isRandomizing) {
            setTargetParams();
            smoothTransition();
        }
    });

    document.getElementById('helpButton').addEventListener('click', () => document.getElementById('helpPopup').classList.add('show'));
    document.getElementById('closeHelp').addEventListener('click', () => document.getElementById('helpPopup').classList.remove('show'));

    document.getElementById('midiToggle').addEventListener('click', () => { 
        isMidiActive = !isMidiActive;
        document.getElementById('midiToggle').textContent = isMidiActive ? 'Disable MIDI' : 'Enable MIDI';
        document.getElementById('midiStatus').textContent = isMidiActive ? (midiOutput ? 'Connected (Output selected)' : 'Connected (No output)') : 'MIDI Disabled'; 
    });

    initAudio(); initMIDI(); initSensors(); initCanvas();
});
    </script>
</body>
</html>
